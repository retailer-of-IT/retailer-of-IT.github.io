<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构 | 倦倚的博客</title><meta name="keywords" content="专业课"><meta name="author" content="倦倚"><meta name="copyright" content="倦倚"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构与算法树和二叉树部分完全二叉树和满二叉树 完全二叉树的特点：叶子节点只可能在层数最大的两层出现  对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个 公式总结 已知完全二叉树的总节点数为n求叶子节点个数：  当n为奇数时：（n+1）&#x2F;2  当n为偶数时 : （n）&#x2F;2  已知完全二叉树的总节点数为n求父节点个数为：n&#x2F;2  已知完全二叉树的总节">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://retailer-of-it.github.io/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="倦倚的博客">
<meta property="og:description" content="数据结构与算法树和二叉树部分完全二叉树和满二叉树 完全二叉树的特点：叶子节点只可能在层数最大的两层出现  对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个 公式总结 已知完全二叉树的总节点数为n求叶子节点个数：  当n为奇数时：（n+1）&#x2F;2  当n为偶数时 : （n）&#x2F;2  已知完全二叉树的总节点数为n求父节点个数为：n&#x2F;2  已知完全二叉树的总节">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images7.alphacoders.com/506/506618.jpg">
<meta property="article:published_time" content="2022-01-04T14:09:04.000Z">
<meta property="article:modified_time" content="2022-01-21T01:48:45.555Z">
<meta property="article:author" content="倦倚">
<meta property="article:tag" content="专业课">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images7.alphacoders.com/506/506618.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://retailer-of-it.github.io/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxxxxx"/><meta name="baidu-site-verification" content="xxxxxxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"KX0MP7ET7V","apiKey":"c9498a706869a5b1e2c560f8354e636c","indexName":"juanyi","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 倦倚","link":"链接: ","source":"来源: 倦倚的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-21 09:48:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/73625138?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images7.alphacoders.com/506/506618.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">倦倚的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-04T14:09:04.000Z" title="发表于 2022-01-04 22:09:04">2022-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-21T01:48:45.555Z" title="更新于 2022-01-21 09:48:45">2022-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E4%BA%8C/">大二</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="树和二叉树部分"><a href="#树和二叉树部分" class="headerlink" title="树和二叉树部分"></a>树和二叉树部分</h2><h3 id="完全二叉树和满二叉树"><a href="#完全二叉树和满二叉树" class="headerlink" title="完全二叉树和满二叉树"></a>完全二叉树和满二叉树</h3><ul>
<li><p>完全二叉树的特点：叶子节点只可能在层数最大的两层出现</p>
</li>
<li><p>对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个</p>
<h4 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结"></a>公式总结</h4></li>
<li><p>已知完全二叉树的总节点数为n求叶子节点个数：</p>
</li>
<li><p>当n为奇数时：（n+1）/2</p>
</li>
<li><p>当n为偶数时 : （n）/2</p>
</li>
<li><p>已知完全二叉树的总节点数为n求父节点个数为：n/2</p>
</li>
<li><p>已知完全二叉树的总节点数为n求叶子节点为2的父节点个数：</p>
</li>
<li><p>当n为奇数时：n/2</p>
</li>
<li><p>当n为偶数时 : n/2-1</p>
</li>
<li><p>具有n个节点的完全二叉树的深度:<br>$$<br>h = [log_2n]+1<br>$$</p>
</li>
<li><p>对于任意二叉树，度为0的节点数为$n_0$,度为1的节点数为$n_1$,度为2的节点数为$n_2$,则有<br>$$<br>n_0=n_2+1<br>$$</p>
</li>
<li><p>对于有n个节点的的完全二叉树，编号1-n，则对于完全二叉树中编号为i的节点，<br>若i=1,为根；若2i&gt;n,则该节点无左孩子，否则2i为左孩子；若2i+1&gt;n,该节点无右孩子节点，否则2i+1为右孩子节点</p>
</li>
<li><p>n个节点的二叉树中，共有n+1个空指针域</p>
</li>
<li><p>一棵完全二叉树有n个叶子节点，则最多有2n个总节点，最少2n-1个总节点</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3></li>
<li><p>链式存储和顺序存储</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>leftchild</th>
<th>data</th>
<th>rightchild</th>
</tr>
</thead>
<tbody><tr>
<td>c语言描述</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BitNode&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    struct BitNode*lch,*rch;</span><br><span class="line">&#125;BitNode,*Bitree;</span><br></pre></td></tr></table></figure>
<ul>
<li>几种改进以及常见的表示方法：</li>
</ul>
<ol>
<li>带有双亲指针的二叉链表，加入一个parent指针域<h4 id="双亲表示法："><a href="#双亲表示法：" class="headerlink" title="双亲表示法："></a>双亲表示法：</h4>用一组连续的存储空间来存放每个节点，同时每个节点有一个伪指针，指示双亲节点在数组中的尾汁，其中根节点的下标为0，其伪指针域为-1，如图<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CBUO0MRM-1613267756201)(<a target="_blank" rel="noopener" href="https://pad.degrowth.net/uploads/upload_a1078dd5be4549e4ec2dca9e7c06bff8.png)]">https://pad.degrowth.net/uploads/upload_a1078dd5be4549e4ec2dca9e7c06bff8.png)]</a><br>代码：<img src="https://img-blog.csdnimg.cn/img_convert/7007df84542bcc392ef7bc9da83733bd.png"></li>
</ol>
<h4 id="孩子表示法："><a href="#孩子表示法：" class="headerlink" title="孩子表示法："></a>孩子表示法：</h4><p>将每个节点的孩子节点都用单链表连起来形成一个线性结构，n个节点具有n个孩子链表，如图<br><img src="https://img-blog.csdnimg.cn/img_convert/1c3cf96dcb87486d7a5467a2187efcbb.png"></p>
<h4 id="孩子兄弟表示法："><a href="#孩子兄弟表示法：" class="headerlink" title="孩子兄弟表示法："></a>孩子兄弟表示法：</h4><p>左孩子右兄弟，代码<img src="https://img-blog.csdnimg.cn/img_convert/d84cb29994f9512d44d77ca3bd55a5e8.png"></p>
<table>
<thead>
<tr>
<th>节点的第一个孩子节点指针</th>
<th>节点值</th>
<th>节点的下一个兄弟节点指针</th>
</tr>
</thead>
<tbody><tr>
<td>如图：</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/img_convert/e0cef26ed7f8fd36d69a8f65e67c70bb.png"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：<img src="https://img-blog.csdnimg.cn/img_convert/ba03289191cb633f53a6cec78ac89cb6.png"></h4><h3 id="二叉树的遍历（递归算法）"><a href="#二叉树的遍历（递归算法）" class="headerlink" title="二叉树的遍历（递归算法）"></a>二叉树的遍历（递归算法）</h3><ul>
<li>先序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根<br>（先判断二叉树非空）<br><font color="red">给定前序和后序不能唯一确定二叉树，但只要有中序就行</font><h3 id="二叉树的遍历（非法递归算法）"><a href="#二叉树的遍历（非法递归算法）" class="headerlink" title="二叉树的遍历（非法递归算法）"></a>二叉树的遍历（非法递归算法）</h3>博客链接：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pkg313133/p/3459171.html">https://www.cnblogs.com/pkg313133/p/3459171.html</a></li>
</ul>
<h3 id="二叉树的等价与相似"><a href="#二叉树的等价与相似" class="headerlink" title="二叉树的等价与相似"></a>二叉树的等价与相似</h3><p>二叉树具有<font color="red">相同结构</font>是指：</p>
<ol>
<li>他们都是空的</li>
<li>他们都是非空的，但左右字数具有相同的结构。</li>
</ol>
<p><strong>定义满足2的为相似二叉树，满足2且相应节点信息相同的为等价二叉树</strong></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>中序线索二叉树的遍历：<br><img src="https://img-blog.csdnimg.cn/img_convert/048dbb7b5459ea5d3f074b086b95ba63.png"><br>注意：中序的前驱和后继都指向祖先<br>前序线索二叉树找前驱困难；中序都差不多，后序找后继困难</p>
<h4 id="树和二叉树，森林的转换"><a href="#树和二叉树，森林的转换" class="headerlink" title="树和二叉树，森林的转换"></a>树和二叉树，森林的转换</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/77d914cde512ac761de7597ebbe590fc.png"><br>互逆，且转换方式唯一<br>具体转换方式参照这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tjh625/article/details/87839191">https://blog.csdn.net/tjh625/article/details/87839191</a></p>
<ul>
<li>森林和树的遍历：与二叉树相似，有先根，后根，层次遍历三种（没有中根）<br><font color="red">树的先根遍历和这棵树对应的二叉树的先序遍历相同；<br>  树的后根遍历序列与这棵树对应二叉树的中序遍历相同</font><br>森林的先序遍历就是依次对应二叉树进行先根遍历，森林的中序遍历就是对与森林对应二叉树的中序遍历</li>
<li>相关链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/linraise/article/details/11745559">https://blog.csdn.net/linraise/article/details/11745559</a></li>
</ul>
<h3 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h3><h4 id="二叉排序树（二叉查找树）BST"><a href="#二叉排序树（二叉查找树）BST" class="headerlink" title="二叉排序树（二叉查找树）BST"></a>二叉排序树（二叉查找树）BST</h4><p><strong>性质：每个节点，若左子树非空，左子树的所有节点关键值均小于该节点，右子树关键值均大于该节点</strong>（是一种递归结构）<br>对二叉排序树进行中序遍历，可得到一个递增的有序序列，查找效率非常高</p>
<ul>
<li>二叉树的一些操作</li>
</ul>
<ol>
<li>查找<br><img src="https://img-blog.csdnimg.cn/img_convert/43329f8210c88fdfd5ae4033acfbaae6.png"></li>
<li>插入<br><img src="https://img-blog.csdnimg.cn/img_convert/ff8a89a3eb1a874f80ea6194dd2cd2f3.png"></li>
<li>构造<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zArGtbAZ-1613267756215)(<a target="_blank" rel="noopener" href="https://pad.degrowth.net/uploads/upload_aASL1856c20f88157f83b7f43416db3f757.png)]">https://pad.degrowth.net/uploads/upload_aASL1856c20f88157f83b7f43416db3f757.png)]</a></li>
<li>删除</li>
</ol>
<ul>
<li>若被删除节点是叶子节点，直接删除</li>
<li>若被删除节点只有一颗子树，则让z的子数成为z父节点的子树（长子继承）</li>
<li>若被删除节点有两颗子树，则让z的中序序列的直接后继代替z，并删除直接后继节点(难)</li>
</ul>
<p>注意：二叉排序树中删除并插入某节点，得到的二叉排序树和原来不一定相同。<br>    二叉排序树最大元和最小元不一定是叶子<br>5. 查找效率（ASL）<br>平均查找长度取决于树的高度<br>ASL = 每个节点的层次相加最后取平均<br>平衡二叉树的查找效率最高</p>
<h4 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h4><p>n个叶子节点的二叉树，每个叶子节点带权，则必存在一棵带权路径长度WPL最小的树，成为霍夫曼树。<br>$$<br>带权路径长度（WSL）= \sum w_i\times L_i<br>$$</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/17fbc6002d804cbec239bf41d64de971.png"></p>
<h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p>性质：左右子树高度差绝对值不超过1<br>高度为h的最小（节点数最少）平衡二叉树的节点数$N_h$<br><img src="https://img-blog.csdnimg.cn/img_convert/7cd8bba0c44a25672dd55b6cc4e880c9.png"><br>AVL旋转操作：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24336773/article/details/81712866">https://blog.csdn.net/qq_24336773/article/details/81712866</a></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>顶点(Vertex)、弧(Arc)、弧头(初始点)、弧尾(终结点)、边(Edge)、有向图(Directed graph)、无向图(Undigraph)、完全图(Completed grapg)、有向完全图、稀疏图(Sparse graph)、稠密图(Dense graph)、连通、连通图(Connected graph)、连通分量(Connected Component)、强连通图、强连通分量(有向图中的极大强连通子图)、生成树、极小连通子图、有向树。</p>
<ul>
<li><p>无向图：G=(V, {E})、0≤边≤n(n-1)/2</p>
</li>
<li><p>有向图：G=(V, {A})、0≤弧≤n(n-1)</p>
</li>
<li><p>连通图：在无向图G中，如果图中任意两个顶点vi, vj属于V，vi和vj都是连通的，则图G是连通图。</p>
</li>
<li><p>连通分量：无向图中的极大连通子图</p>
</li>
<li><p>强连通图：在有向图G中，如果每一对顶点vi, vj属于V且vi不等于vj，从vi到vj与从vj到vi都存在路径，则图G是连通图。</p>
</li>
<li><p>强连通分量：有向图的极大强连通子图。</p>
</li>
<li><p>生成树：一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边。</p>
</li>
<li><p>如果在生成树上添加一条边，必定构成一个环：因为这条边使得它依附的那两个顶点之间有了第二条路径。</p>
</li>
<li><p>一个有n个顶点的生成树有且仅有n-1条边。如果一个图有n和顶点和小于n-1条的边，则是非连通图。如果多余n-1条边，则一定有环。但有n-1条边的图不一定是生成树。<br><font color="red"><strong>博客</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013071074/article/details/28308275">https://blog.csdn.net/u013071074/article/details/28308275</a></font></p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>用两个数组来表示图。一个一维数组存储图中数据元素（顶点）的信息，一个二维数组（邻接矩阵）存储图中数据元素之间的关系（边或弧）的信息。</p>
<h4 id="邻接表法："><a href="#邻接表法：" class="headerlink" title="邻接表法："></a>邻接表法：</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/cfe27e3c4f7300adb090e79cb057869b.png"><br>注意：无向图的邻接表中，每一条无向边要被存储两次（因为单一有方向）如图<br><img src="https://img-blog.csdnimg.cn/img_convert/53b5ee77ee2c0f4bc9d24c2758ce1a58.png"><br>代码实现：<img src="https://img-blog.csdnimg.cn/img_convert/858565afc3ddc3ad2094ea3cc79e951a.png"></p>
</li>
<li><p>若G为无向图，存储空间为O(|V|+2|E|)</p>
</li>
<li><p>若G为有向图，存储空间为O(|V|+|E|)<br><img src="https://img-blog.csdnimg.cn/img_convert/aafc499e4c6b529b80c1c51d93385243.png"><br>两种存储结构对比：邻接表优于邻接矩阵</p>
<h4 id="十字链表法（比较复杂）"><a href="#十字链表法（比较复杂）" class="headerlink" title="十字链表法（比较复杂）"></a>十字链表法（比较复杂）</h4><p>博文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/bible_reader/article/details/71214096">https://blog.csdn.net/bible_reader/article/details/71214096</a></p>
<h4 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/6e1b623375c70dff0cac06434500ab5a.png"><br>矩阵优于链表（无论是有向图还是无向图）</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5b90f6141d006f8506eb2d056c0155fe.png"><br>链表优于矩阵（无向图），有向图反之</p>
<p>插入点操作（Insert(G,x)）删除点操作（Delete(G,x)）<br>对应修改相应的邻接矩阵和邻接表即可。</p>
<h3 id="深度优先算法"><a href="#深度优先算法" class="headerlink" title="深度优先算法"></a>深度优先算法</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/8d8d1483ec96ac26e3af211b7bfe9a88.png"><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MAX_TREE_SIZE]</span><br><span class="line">void DFSTraverse(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0;i&lt;v.vexnum;i++)</span><br><span class="line">        visited[i]=FALSE;</span><br><span class="line">    for(int i=0;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            DFS(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(Graph G,int v)</span><br><span class="line">&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=TRUE;</span><br><span class="line">    for(w=Firstneighbor(G,v);w&gt;=0;w=Nextneighbor(G,v,w))</span><br><span class="line">        if(!visited(w))</span><br><span class="line">            DFS(G,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法性能分析：空间复杂度：O(|V|)<br>时间复杂度：</p>
<p>| 邻接矩阵   | O(V^2)|<br>| ——–  | ——–| ——– |<br>| 邻接表法   | O(V+E)|<br><img src="https://img-blog.csdnimg.cn/img_convert/8a5d4dcc2e087dbca8c36d60aeeebb20.png"></p>
<h3 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7af010cc87dfaff04f50f9d30648628f.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/866b7f60494c7d823f7643fe79217248.png"><br>BFSTraverse的作用是针对那些没有联通的顶点进行遍历<br><img src="https://img-blog.csdnimg.cn/img_convert/8680598919c39ff66b5b1bb9ce939f06.png"></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul>
<li>性质：图的最小生成树不一定唯一（唯一的情况是各边权值不等）</li>
<li>最小生成树算法：<br>prim算法（防止了环的生成）<br><img src="https://img-blog.csdnimg.cn/img_convert/5121d838d884685c44fe8bbdbf475bc3.png"><br>两个数组：min_weight记录边的权值（全部为0，生成结束）  adjvex记录U集合中的顶点（该点上一个点的下标）<br><img src="https://img-blog.csdnimg.cn/img_convert/524eab845842f005b8e957f5ce6439e5.png"><br>代码如下：(O|$n^2$|)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void MST_Prim(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    int min_weight[G.vexnum];</span><br><span class="line">    int adjvex[G.vexnum];</span><br><span class="line">    for(int i = 0;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    min_weight[i] = G.edge[0][i];</span><br><span class="line">    adjvex[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">    int min_arc;</span><br><span class="line">    int min_vex;</span><br><span class="line">    for(int i = 1;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        min_arc = MAX;</span><br><span class="line">        for(int j = 1;j&lt;G.vexnum;j++)</span><br><span class="line">            if(min_weight[j]!=0&amp;&amp;min_weight[j]&lt;min_arc)&#123;</span><br><span class="line">                min_arc = min_weight[j];</span><br><span class="line">                min_vex = j;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        min_weight[min_vex] = 0;</span><br><span class="line">        for(int j = 0;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">            if(min_weight[j]!=0&amp;&amp;G.edge[min_arc][j]&lt;min_weight[j])&#123;</span><br><span class="line">            min_weight[j]=G.efge[min_arc][j];</span><br><span class="line">            adjvex[j] = min_vex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
适合稠密图<br>Kruskal算法<br><img src="https://img-blog.csdnimg.cn/img_convert/1d6f9cd77655d83a2b31e14d0eed15a0.png"><br>代码：<br><img src="https://img-blog.csdnimg.cn/img_convert/fb5ca59b45ff7fd900d31a587061a0fd.png"><br>适合于稀疏图，复杂度O(eloge)(e为边)</li>
</ul>
<h3 id="有向无环图（DAG）"><a href="#有向无环图（DAG）" class="headerlink" title="有向无环图（DAG）"></a>有向无环图（DAG）</h3><ul>
<li>不存在环的有向图</li>
<li>AOV网：用DAG表示一个工程，顶点表示活动，&lt;vi,vj&gt;表示活动传递关系的网络</li>
<li>拓扑排序：对DAG所有顶点的排序，使得若存在一条从顶点A到顶点B的路径，在排序中B排在A后面<br><img src="https://img-blog.csdnimg.cn/img_convert/1819bf9facb9ffbe96af3eef43b6ccca.png"><br><font color="red">一个有向无环图拓扑排序序列不一定唯一；有向有环图无拓扑序列<br>如果顶点还未输出完就已经找不到入度为0的顶点，说明有环，退出</font>
代码：（用一个栈辅助）
![](https://img-blog.csdnimg.cn/img_convert/dee3dc6a90e1f118b7f87963121f8315.png)
复杂度（O|V|+|E|）
结论：若邻接矩阵为三角矩阵，则存在拓扑排序；反之不一定成立
Indegree函数：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//求各顶点入度的程序</span><br><span class="line">void FindInDegree(ALGraph G, int indegree[])</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  ArcNode *p;</span><br><span class="line">  for (i = 0; i &lt; G.Vexnum; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p = G.Vertices[i].firstarc;</span><br><span class="line">    while (p)</span><br><span class="line">    &#123;</span><br><span class="line">      indegree[p-&gt;adjvex]++;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><ul>
<li>概念：(AOE网)带权有向图，边表示活动，权表示持续时间（一般）</li>
<li>特点：只有一个出度为0的点（汇点）,一个入度为0（源点）</li>
<li>最短时间是源点到汇点的最长路径长度（关键路径）</li>
<li>关键路径上的活动：关键活动</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/859ebb8241797d6e1f611363d88467b8.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d22eb1d17cbe5796b6964a01cb9fc4dc.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c6ead9d812d20c26791562a936f9dda3.png"><br>最长时间与最短时间相减为0的为关键路径节点（即相等），关键活动<br>链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/mgsky1/article/details/78124565">https://blog.csdn.net/mgsky1/article/details/78124565</a></p>
<h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><ul>
<li>dijkstra算法（单源最短路径算法）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f75684ad098af62a8ce2f4d35e4d1cc1.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9a235a772962084032a019e8fadbb3ee.png"><br>代码：<br><img src="https://img-blog.csdnimg.cn/img_convert/bf14010141037815baf3810fbcbbdd64.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/94cfdcee3e1c7b1ac2f934dbd10306e1.png"><br>注意：迪杰斯特拉算法的权值不能为负数</p>
<ul>
<li>Floyd算法（各顶点之间最短路径）<br>适用范围：无负权回路即可，边权可正可负，运行一次算法即可求得任意两点间最短路。</li>
</ul>
<p><strong>基本思想：<br>弗洛伊德算法定义了两个二维矩阵：<br>矩阵D记录顶点间的最小路径<br>例如D[0][3]= 10，说明顶点0 到 3 的最短路径为10；<br>矩阵P记录顶点间最小路径中的中转点<br>例如P[0][3]= 1 说明，0 到 3的最短路径轨迹为：0 -&gt; 1 -&gt; 3。<br>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v][w] 和 D[v][k] + D[k][w] 最小值，如果D[v][k] + D[k][w] 为更小值，则把D[v][k] + D[k][w] 覆盖保存在D[v][w]中。</strong></p>
<ul>
<li>结构定义：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct struct_graph&#123;</span><br><span class="line">    char vexs[MAXN];</span><br><span class="line">    int vexnum;//顶点数 </span><br><span class="line">    int edgnum;//边数 </span><br><span class="line">    int matirx[MAXN][MAXN];//邻接矩阵 </span><br><span class="line">&#125; Graph;</span><br></pre></td></tr></table></figure></li>
<li>核心算法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//这里是弗洛伊德算法的核心部分 </span><br><span class="line">    //k为中间点 </span><br><span class="line">    for(k = 0; k &lt; G.vexnum; k++)&#123;</span><br><span class="line">        //v为起点 </span><br><span class="line">        for(v = 0 ; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">            //w为终点 </span><br><span class="line">            for(w =0; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">                if(D[v][w] &gt; (D[v][k] + D[k][w]))&#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];//更新最小路径 </span><br><span class="line">                    P[v][w] = P[v][k];//更新最小路径中间顶点 </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
代码汇总：<a target="_blank" rel="noopener" href="https://blog.csdn.net/o1101574955/article/details/44223917/">https://blog.csdn.net/o1101574955/article/details/44223917/</a><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2></li>
</ul>
<h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><p>一种优化：带哨兵(防止下标越界，提高效率)<br>代码如下：从后往前查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Sequential_Search2(int *a int n,int key)</span><br><span class="line">&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	a[0]=key;//哨兵</span><br><span class="line">	i=n;</span><br><span class="line">	while(a[i]!=key)</span><br><span class="line">	&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	return i;//返回0就是查找失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功平均查找长度：（n+1）/2<br>失败平均查找长度：  n+1</p>
<h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int search(keytype key[],int n,keytype k)</span><br><span class="line">&#123;</span><br><span class="line"> 	int low=0,high=n-1,mid;</span><br><span class="line"> 	while(low&lt;=high)</span><br><span class="line"> 	&#123;</span><br><span class="line">  		mid=(low+high)/2;</span><br><span class="line">  		if(key[mid]==k)</span><br><span class="line">   			return mid;	//查找成功，返回mid </span><br><span class="line">  		if(k&gt;key[mid])</span><br><span class="line">   			low=mid+1;	//在后半序列中查找 </span><br><span class="line">  		else</span><br><span class="line">   			high=mid-1;	//在前半序列中查找 </span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return -1;//查找失败，返回-1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O（log2n）</p>
<ul>
<li>以上算法只适用于关键字顺序递增的有序表查找。如果该顺序表是关键字递减的，则算法需要改动，在low指针与high指针的修改上对调即可。</li>
<li>查找成功的最多比较次数：[log2(n+1)],失败的次数为[log2(n+1)]</li>
</ul>
<h4 id="索引顺序表查找算法（分块查找算法）"><a href="#索引顺序表查找算法（分块查找算法）" class="headerlink" title="索引顺序表查找算法（分块查找算法）"></a>索引顺序表查找算法（分块查找算法）</h4><ul>
<li><p>算法背景<br>有时候，可能会遇到这样的表：整个表中的元素未必有序，但若划分为若干块后，每一块中的所有元素均小于（或大于）其后面块中的所有元素。我们称这种为分块有序。</p>
</li>
<li><p>对于分块有序表的查找<br>首先，我们需要先建立一个索引表，索引表中为每一块都设置–索引项，每一个索引项都包含两个内容：<br>该块的起始地址<br>该块中最大（或最小）的元素</p>
</li>
<li><p>查找过程<br>在前面建立的索引表的基础上，我们查找一个关键字需要两个步骤：<br>在索引表中查找，目的是找出关键所属的块的位置。这里如果索引表较大的话，可以采用折半查找。<br>进入该块中，使用简单顺序表查找算法进行关键字查找。</p>
</li>
<li><p>算法分析<br>分块查找的平均查找长度为ASLbs = Lb+Lw， 其中Lb为查找索引表确定所在块的平均查找长度，Lw为在块中查找元素的平均查找长度。<br>一般情况下，为进行分块查找，可以将长度为n的表均匀地分成b块，每块含有s个记录，即b=[n/s];又假定表中每个记录的查找概率相等，则每块查找的概率为1/b，块中每个记录的查找概率为1/s。<br>若用顺序查找确定所在块，顺序查找子表中的元素，则分块查找的平均查找长度为：<br><img src="https://img-blog.csdnimg.cn/img_convert/6cdccb92c0d4852d48ff51a9e993bde6.png"><br>长度为n的线性表，分成$sqrt(n)$(根号n)查找次数最少<br><img src="https://img-blog.csdnimg.cn/img_convert/9266e9691334f506e4a34fd645d7f703.png"></p>
</li>
</ul>
<h4 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h4><ul>
<li>二叉排序树</li>
<li>二叉平衡树</li>
</ul>
<h4 id="哈希函数法"><a href="#哈希函数法" class="headerlink" title="哈希函数法"></a>哈希函数法</h4><ul>
<li>直接定址法</li>
<li>质数除余法（取不超过表长的最大质数模）</li>
<li>平方取中法<br>解决冲突的方法：</li>
<li>开放地址法（删除元素后再查找会造成问题）<br>用于顺序存储结构</li>
<li>拉链法:适用于经常进行删除操作的</li>
<li>装载因子：反映哈希表的饱和程度：n/m  n为记录数，m为表长</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>总览：<br><img src="https://img-blog.csdnimg.cn/img_convert/481756935f54c03fe69644224498d132.png"></p>
<h3 id="稳定类"><a href="#稳定类" class="headerlink" title="稳定类"></a>稳定类</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//插入排序</span><br><span class="line">#define MAXSIZE 10000</span><br><span class="line">typedef int KeyType;</span><br><span class="line">]typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  KeyType key;</span><br><span class="line">  InfoType otherinfo;</span><br><span class="line">&#125; RcdType;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  RcdType r[MAXSIZE + 1]; //r0闲置，哨兵</span><br><span class="line">  int length;</span><br><span class="line">&#125; SqList;</span><br><span class="line">void Insertsort(Sqlist &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">  int i, j;</span><br><span class="line">  for (i = 2; i &lt;= L.length; i++)</span><br><span class="line">    if (L.r[i].key &lt; L.r[i - 1].key)</span><br><span class="line">    &#123;</span><br><span class="line">      L.r[0] = L.r[i];//监视哨起占位作用</span><br><span class="line">      for (j = i - 1; L.r[0].key &lt; L.r[j].key; --j)</span><br><span class="line">        L.r[j + 1] = L.r[j];</span><br><span class="line">      L.r[j + 1] = L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; //直接插入排序在原序列正向有序时最省时间，反之最费时间</span><br></pre></td></tr></table></figure>
<p>平均时间复杂度：O(n^2),空间O(1),可适用于链式存储结构</p>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>代码：<br><img src="https://img-blog.csdnimg.cn/img_convert/72478dfa92ea2ccb38d4e847fa03cd82.png"><br>就是二分+插入的结合<br>复杂度与之前相同，只适用于顺序存储</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/2f38735571f9b300aef709282ae121b0.png"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2fbf37b3cf838ad0105f30d1959c532e.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/8e180ddc47d12ad3643879cfeaebff34.png"><br>时间复杂度：nlog2n,空间：O(n)</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>类似于桶排序，有分配和收集<br>个位，十位，百位，不基于比较</p>
<h3 id="不稳定类"><a href="#不稳定类" class="headerlink" title="不稳定类"></a>不稳定类</h3><h4 id="希尔排序（缩小增量排序）"><a href="#希尔排序（缩小增量排序）" class="headerlink" title="希尔排序（缩小增量排序）"></a>希尔排序（缩小增量排序）</h4><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//选择排序</span><br><span class="line">void SelectSort(Sqlist &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">  int i, j, low;</span><br><span class="line">  for (i = 1; i &lt;= L.length; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    low = i;</span><br><span class="line">    for (j = i + 1; j &lt;= L.length; j++)</span><br><span class="line">      if (L.r[j].key &lt; L.r[low].key)</span><br><span class="line">        low = j;</span><br><span class="line">    if (i != low)</span><br><span class="line">    &#123;</span><br><span class="line">      L.r[0] = L.r[i];</span><br><span class="line">      L.r[i] = L.r[low];</span><br><span class="line">      L.r[low] = L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较O(n^2),移动最少O(1),最坏O(n)<br>空间O(1)</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
</li>
<li><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了<br>博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">https://www.cnblogs.com/chengxiao/p/6129630.html</a><br><font color="red">完全二叉树最后一个非叶子节点下标为[n/2],n是节点总数</font></p>
</li>
<li><p>堆排序步骤：<br>   1、从k-1层的最右非叶结点开始，使关键字值大（或小）的记录逐步向二叉树的上层移动，最大（或小）关键字记录成为树的根结点，使其成为堆。<br>   2、逐步输出根结点，令r[1]=r<a href="i=n,,n-1,...,2">i</a>，在将剩余结点调整成堆。直到输出所有结点。我们称这个自堆顶到叶子的调整过程为“筛选”。</p>
</li>
<li><p>（3）要解决的两个问题：</p>
<pre><code>１、如何由一个无序序列建成一个堆；
２、输出一个根结点后，如何将剩余元素调整成一个堆。
将一个无序序列建成一个堆是一个反复“筛选”的过程。若将此序列看成是一个完全二叉树，则最后一个非终端结点是第floor(n/2)个元素，由此“筛选”只需从第floor(n/2)个元素开始。
堆排序中需一个记录大小的辅助空间，每个待排的记录仅占有一个存储空间。堆排序方法当记录较少时，不值得提倡。当n很大时，效率很高。堆排序是不稳定的。
</code></pre>
<p>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define MAXSIZE 20</span><br><span class="line"> </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	int key;</span><br><span class="line">	//其他数据信息</span><br><span class="line">&#125;RedType;</span><br><span class="line"> </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	RedType r[MAXSIZE+1];</span><br><span class="line">	int length;</span><br><span class="line">&#125;Sqlist;</span><br><span class="line"> </span><br><span class="line">typedef Sqlist HeapType;  //堆采用顺序表存储表示</span><br><span class="line"> </span><br><span class="line">void HeapAdjust(HeapType &amp;H,int s,int m)   //已知H.r[s...m]中记录的关键字出H.r[s].key之外均满足堆的定义，本函数调整H.r[s]的关键字，使H.r[s...m]成为一个大顶堆（对其中记录的关键字而言）</span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line">	RedType rc;</span><br><span class="line">	rc=H.r[s];</span><br><span class="line">	for(j=2*s;j&lt;=m;j*=2)   //沿key较大的孩子结点向下筛选</span><br><span class="line">	&#123;</span><br><span class="line">		if(j&lt;m &amp;&amp; (H.r[j].key&lt;H.r[j+1].key))     //j为key较大的记录的下标</span><br><span class="line">			++j;</span><br><span class="line">		if(rc.key&gt;=H.r[j].key)           //rc应插入在位置s上</span><br><span class="line">			break;</span><br><span class="line">		H.r[s]=H.r[j];      //将左、右孩子较大的结点与父节点进行交换，建成大顶堆</span><br><span class="line">		s=j;</span><br><span class="line">	&#125;</span><br><span class="line">	H.r[s]=rc;             //插入</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void HeapSort(HeapType &amp;H)      //对顺序表H进行堆排序</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=H.length/2;i&gt;0;--i)   //由一个无序序列建成一个大顶堆，将序列看成是一个完全二叉树，则最后一个非终端节点是第n/2个元素</span><br><span class="line">		HeapAdjust(H,i,H.length);</span><br><span class="line">	for(i=H.length;i&gt;1;--i)</span><br><span class="line">	&#123;</span><br><span class="line">		H.r[0]=H.r[1];   //将堆顶记录和当前未经排序的子序列H.r[1...i]中最后一个记录相互交换</span><br><span class="line">		H.r[1]=H.r[i];</span><br><span class="line">		H.r[i]=H.r[0];</span><br><span class="line">		HeapAdjust(H,1,i-1);    //将H.r[1...i-1]重新调整为大顶堆</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//HeapSort</span><br><span class="line"> </span><br><span class="line">void InputL(Sqlist &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	printf(&quot;Please input the length:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;L.length);</span><br><span class="line">	printf(&quot;Please input the data needed to sort:\n&quot;);</span><br><span class="line">	for(i=1;i&lt;=L.length;i++)    //从数组的第1个下标开始存储，第0个下标作为一个用于交换的临时变量</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;L.r[i].key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void OutputL(Sqlist &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	printf(&quot;The data after sorting is:\n&quot;);</span><br><span class="line">	for(i=1;i&lt;=L.length;i++)</span><br><span class="line">		printf(&quot;%d &quot;,L.r[i].key);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	Sqlist H;</span><br><span class="line">	InputL(H);</span><br><span class="line">	HeapSort(H);</span><br><span class="line">	OutputL(H);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/def1e71f9b7be84e4e4828381172dc09.png"><br>复杂度：O(nlog2n)，既适用于顺序，也适用于链式</p>
</li>
</ul>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/nrsc272420199/article/details/82587933">https://blog.csdn.net/nrsc272420199/article/details/82587933</a><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Paritition1(int A[], int low, int high) &#123;</span><br><span class="line">   int pivot = A[low];</span><br><span class="line">   while (low &lt; high) &#123;</span><br><span class="line">     while (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     A[low] = A[high];</span><br><span class="line">     while (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   return low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void QuickSort(int A[], int low, int high) //快排母函数</span><br><span class="line"> &#123;</span><br><span class="line">   if (low &lt; high) &#123;</span><br><span class="line">     int pivot = Paritition1(A, low, high);</span><br><span class="line">     QuickSort(A, low, pivot - 1);</span><br><span class="line">     QuickSort(A, pivot + 1, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://img-blog.csdnimg.cn/img_convert/048b0c04c7e0c68b092b48733f654e5b.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/98d4f6dd839b8afe2feb396a350a8dba.png"><br>注意：当序列基本有序时，快速排序最不利于发挥长处，在每次划分得到两个长度基本相等的子文件时最易发挥长处</p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/116c61f6b6ecd33f4e4c41e431b39a3b.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">倦倚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://retailer-of-it.github.io/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://retailer-of-it.github.io/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://retailer-of-IT.github.io" target="_blank">倦倚的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a></div><div class="post_share"><div class="social-share" data-image="https://images7.alphacoders.com/506/506618.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://raw.githubusercontent.com/retailer-of-IT/pictures/master/2.png" target="_blank"><img class="post-qr-code-img" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.zgbxjj.com%2Fthemes%2Fkaben%2Fbximg%2Fweixin.png&amp;refer=http%3A%2F%2Fwww.zgbxjj.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1643897101&amp;t=2f80f83288201d5696d61d59961c9d56" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://raw.githubusercontent.com/retailer-of-IT/pictures/9c0dcb8e088dfcdc8f278e2926ae0ea28ae52602/1.jpg" target="_blank"><img class="post-qr-code-img" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp3.itc.cn%2Fq_70%2Fimages03%2F20211125%2Fd384c98973b34b36af84cb4149e1dd2d.png&amp;refer=http%3A%2F%2Fp3.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1643897077&amp;t=fd382f74f9e046f1991b98608036dbe2" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/08/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><img class="prev-cover" src="https://images7.alphacoders.com/508/508473.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">服务器学习</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/03/hello-world/"><img class="next-cover" src="https://images2.alphacoders.com/508/thumb-1920-508526.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/03/2021%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="2021操作系统"><img class="cover" src="https://images5.alphacoders.com/506/thumb-1920-506616.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-03</div><div class="title">2021操作系统</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/73625138?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">倦倚</div><div class="author-info__description">IT🐂🐎一枚</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/retailer-of-IT"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/retailer-of-IT" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:7912459@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_46207366?spm=1001.2101.3001.5343" target="_blank" title=""><i class="fa fa-binoculars"></i></a><a class="social-icon" href="qq:1343491697" target="_blank" title=""><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">人生在勤，不索何获</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E9%83%A8%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">树和二叉树部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">完全二叉树和满二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">公式总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">双亲表示法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">孩子表示法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%9A"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">孩子兄弟表示法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">二叉树的遍历（递归算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E6%B3%95%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">二叉树的遍历（非法递归算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%AD%89%E4%BB%B7%E4%B8%8E%E7%9B%B8%E4%BC%BC"><span class="toc-number">1.1.5.</span> <span class="toc-text">二叉树的等价与相似</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.6.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">树和二叉树，森林的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.7.</span> <span class="toc-text">树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89BST"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">二叉排序树（二叉查找树）BST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">霍夫曼树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="toc-number">1.1.8.</span> <span class="toc-text">平衡二叉树（AVL）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">邻接表法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95%EF%BC%88%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%EF%BC%89"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">十字链表法（比较复杂）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">图的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">深度优先算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">广度优先算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.2.4.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%EF%BC%88DAG%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">有向无环图（DAG）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.2.6.</span> <span class="toc-text">关键路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.7.</span> <span class="toc-text">最短路径算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">静态查找表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">有序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">折半查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">索引顺序表查找算法（分块查找算法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">动态查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E6%B3%95"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">哈希函数法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">稳定类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">基数排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%A8%B3%E5%AE%9A%E7%B1%BB"><span class="toc-number">1.4.2.</span> <span class="toc-text">不稳定类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">希尔排序（缩小增量排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/22/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="寒假刷题（基础）"><img src="https://images5.alphacoders.com/100/1003363.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="寒假刷题（基础）"/></a><div class="content"><a class="title" href="/2022/01/22/%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="寒假刷题（基础）">寒假刷题（基础）</a><time datetime="2022-01-22T04:09:22.000Z" title="发表于 2022-01-22 12:09:22">2022-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/08/%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="服务器学习"><img src="https://images7.alphacoders.com/508/508473.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务器学习"/></a><div class="content"><a class="title" href="/2022/01/08/%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="服务器学习">服务器学习</a><time datetime="2022-01-08T13:36:37.000Z" title="发表于 2022-01-08 21:36:37">2022-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img src="https://images7.alphacoders.com/506/506618.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构"/></a><div class="content"><a class="title" href="/2022/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><time datetime="2022-01-04T14:09:04.000Z" title="发表于 2022-01-04 22:09:04">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/03/hello-world/" title="Hello World"><img src="https://images2.alphacoders.com/508/thumb-1920-508526.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/01/03/hello-world/" title="Hello World">Hello World</a><time datetime="2022-01-03T05:31:23.000Z" title="发表于 2022-01-03 13:31:23">2022-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/03/2021%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="2021操作系统"><img src="https://images5.alphacoders.com/506/thumb-1920-506616.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021操作系统"/></a><div class="content"><a class="title" href="/2022/01/03/2021%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="2021操作系统">2021操作系统</a><time datetime="2022-01-03T05:31:23.000Z" title="发表于 2022-01-03 13:31:23">2022-01-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://images7.alphacoders.com/506/506618.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 倦倚</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QmQ2tVImKk7orvD3lRlAfYAL-gzGzoHsz',
      appKey: 'sgX01T0ecc4EuxPwMitnkABA',
      placeholder: '记得留下您的昵称和邮箱以便我和您取得联系，站点可留空....',
      avatar: 'monsterid',
      meta: '昵称,邮箱,网址'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["昵称,邮箱"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>